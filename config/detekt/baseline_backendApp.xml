<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues>
    <ID>TooGenericExceptionCaught:TokenManager.kt$TokenManagerImpl$e: Exception</ID>
  </ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ArgumentListWrapping:AttachmentRoutes.kt$(DocumentUploadValidator.DEFAULT_MAX_FILE_SIZE_BYTES)</ID>
    <ID>ArgumentListWrapping:AuthService.kt$AuthService$( Permission.InvoicesRead, Permission.ClientsRead, Permission.ReportsView )</ID>
    <ID>ArgumentListWrapping:AuthService.kt$AuthService$( Permission.InvoicesRead, Permission.InvoicesCreate, Permission.InvoicesEdit, Permission.ClientsRead, Permission.ReportsView )</ID>
    <ID>ArgumentListWrapping:AuthService.kt$AuthService$( Permission.InvoicesRead, Permission.InvoicesCreate, Permission.InvoicesEdit, Permission.InvoicesSend, Permission.ClientsRead, Permission.ClientsManage, Permission.ReportsView, Permission.ExportsCreate )</ID>
    <ID>ArgumentListWrapping:AuthService.kt$AuthService$("User ${userId.value} at session limit ($activeSessions/$maxConcurrentSessions), revoking oldest session")</ID>
    <ID>ArgumentListWrapping:CashflowDocumentRoutes.kt$("Fetched ${it.items.size} cashflow documents (offset=${route.offset}, limit=${route.limit}, total=${it.total})")</ID>
    <ID>ArgumentListWrapping:CashflowOverviewService.kt$CashflowOverviewService$("Calculating cashflow overview for tenant: $tenantId (from=$effectiveFromDate, to=$effectiveToDate)")</ID>
    <ID>ArgumentListWrapping:ContactRoutes.kt$("Failed to update contact Peppol settings: ${it.message}")</ID>
    <ID>ArgumentListWrapping:ContactService.kt$ContactService$("Listing contacts for tenant: $tenantId (isActive=$isActive, peppolEnabled=$peppolEnabled, limit=$limit, offset=$offset)")</ID>
    <ID>ArgumentListWrapping:DocumentProcessingWorker.kt$DocumentProcessingWorker$("Deleted $deletedCount old chunks for document $documentId (old hash=$existingHash, new hash=$contentHash)")</ID>
    <ID>ArgumentListWrapping:DocumentProcessingWorker.kt$DocumentProcessingWorker$("Embedding count mismatch: expected ${chunkingResult.chunks.size}, got ${embeddings.size}")</ID>
    <ID>ArgumentListWrapping:DocumentProcessingWorker.kt$DocumentProcessingWorker$("Starting document processing worker (interval=${config.pollingInterval}ms, batch=${config.batchSize}, RAG=${isRagEnabled})")</ID>
    <ID>ArgumentListWrapping:DocumentProcessingWorker.kt$DocumentProcessingWorker$("Stored ${chunksWithEmbeddings.size} chunks with embeddings for document $documentId (hash=$contentHash)")</ID>
    <ID>ArgumentListWrapping:DocumentRecordRoutes.kt$("Invoice creation from document requires contact selection. Use /api/v1/invoices instead.")</ID>
    <ID>ArgumentListWrapping:DocumentRecordRoutes.kt$("Reprocessing document: $documentId, force=${request.force}, " + "overrides=[maxPages=${request.maxPages}, dpi=${request.dpi}, timeout=${request.timeoutSeconds}s], " + "tenant=$tenantId")</ID>
    <ID>ArgumentListWrapping:InvoiceNumberConcurrencyTest.kt$InvoiceNumberConcurrencyTest$((1..numberOfRequests).toList(), results.sorted(), "Numbers should be sequential 1-$numberOfRequests")</ID>
    <ID>ArgumentListWrapping:SmtpEmailService.kt$SmtpEmailService$("SMTP Email Service initialized (host: ${config.smtp.host}, port: ${config.smtp.port}, TLS: ${config.smtp.enableTls})")</ID>
    <ID>CyclomaticComplexMethod:AttachmentRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.attachmentRoutes()</ID>
    <ID>CyclomaticComplexMethod:InboundInvoiceService.kt$InboundInvoiceService$private fun categorizeSupplier(supplierName: String?): ExpenseCategory</ID>
    <ID>CyclomaticComplexMethod:ChatRoutes.kt$internal fun Route.chatRoutes()</ID>
    <ID>CyclomaticComplexMethod:ContactEnrichmentService.kt$ContactEnrichmentService$private fun calculateEnrichmentFields( contact: ContactDto, data: EnrichmentData ): Pair&lt;List&lt;Pair&lt;String, String>>, List&lt;String>></ID>
    <ID>CyclomaticComplexMethod:DocumentProcessingWorker.kt$DocumentProcessingWorker$private suspend fun processIngestionRun(ingestion: IngestionItemEntity)</ID>
    <ID>CyclomaticComplexMethod:DocumentRecordRoutes.kt$internal fun Route.documentRecordRoutes()</ID>
    <ID>CyclomaticComplexMethod:ExpenseService.kt$ExpenseService$fun categorizeExpense(merchant: String, description: String? = null): ExpenseCategory</ID>
    <ID>CyclomaticComplexMethod:PeppolRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.peppolRoutes()</ID>
    <ID>CyclomaticComplexMethod:TenantRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.tenantRoutes()</ID>
    <ID>FinalNewline:RateLimitCleanupWorker.kt$tech.dokus.backend.worker.RateLimitCleanupWorker.kt</ID>
    <ID>ForbiddenComment:AuthService.kt$AuthService$// TODO: Get from tenant</ID>
    <ID>ForbiddenComment:ChatRoutes.kt$// TODO: Track from LLM response</ID>
    <ID>ForbiddenComment:InvoiceRoutes.kt$// TODO: Implement email sending via EmailService when available</ID>
    <ID>ForbiddenComment:InvoiceRoutes.kt$// TODO: Implement payment recording via PaymentService when available</ID>
    <ID>ForbiddenComment:PaymentRoutes.kt$// TODO: Implement overdue payments listing</ID>
    <ID>ForbiddenComment:PaymentRoutes.kt$// TODO: Implement payment listing</ID>
    <ID>ForbiddenComment:PaymentRoutes.kt$// TODO: Implement payment retrieval</ID>
    <ID>ForbiddenComment:PaymentRoutes.kt$// TODO: Implement pending payments listing</ID>
    <ID>ForbiddenComment:PaymentRoutes.kt$// TODO: Implement refunds listing</ID>
    <ID>ForbiddenComment:TeamService.kt$TeamService$// TODO: Use membership createdAt</ID>
    <ID>ImportOrdering:AccountRoutes.kt$import tech.dokus.database.repository.auth.UserRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.model.auth.DeactivateUserRequest import tech.dokus.domain.model.auth.LogoutRequest import tech.dokus.domain.model.auth.SelectTenantRequest import tech.dokus.domain.model.auth.UpdateProfileRequest import tech.dokus.domain.routes.Account import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.get import io.ktor.server.resources.patch import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.auth.AuthService</ID>
    <ID>ImportOrdering:AttachmentRoutes.kt$import tech.dokus.database.repository.cashflow.DocumentRepository import tech.dokus.database.repository.cashflow.ExpenseRepository import tech.dokus.database.repository.cashflow.InvoiceRepository import tech.dokus.domain.enums.EntityType import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.AttachmentId import tech.dokus.domain.ids.DocumentId import tech.dokus.domain.ids.ExpenseId import tech.dokus.domain.ids.InvoiceId import tech.dokus.domain.model.AttachmentDto import tech.dokus.domain.model.DocumentDto import tech.dokus.domain.routes.Attachments import tech.dokus.domain.routes.Expenses import tech.dokus.domain.routes.Invoices import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import tech.dokus.foundation.backend.storage.DocumentUploadValidator import io.ktor.http.HttpStatusCode import io.ktor.http.content.PartData import io.ktor.http.content.forEachPart import io.ktor.server.request.receiveMultipart import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.post import io.ktor.server.response.respond import io.ktor.server.routing.Route import io.ktor.server.routing.RoutingContext import kotlinx.serialization.Serializable import org.koin.ktor.ext.inject import org.slf4j.LoggerFactory import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid import tech.dokus.foundation.backend.storage.DocumentStorageService as MinioDocumentStorageService</ID>
    <ID>ImportOrdering:AuthService.kt$import tech.dokus.database.repository.auth.RefreshTokenRepository import tech.dokus.database.repository.auth.UserRepository import tech.dokus.domain.enums.Permission import tech.dokus.domain.enums.SubscriptionTier import tech.dokus.domain.enums.UserRole import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.TenantId import tech.dokus.domain.ids.UserId import tech.dokus.domain.model.TenantMembership import tech.dokus.domain.model.User import tech.dokus.domain.model.auth.JwtClaims import tech.dokus.domain.model.auth.LoginRequest import tech.dokus.domain.model.auth.LoginResponse import tech.dokus.domain.model.auth.LogoutRequest import tech.dokus.domain.model.auth.RefreshTokenRequest import tech.dokus.domain.model.auth.RegisterRequest import tech.dokus.domain.model.auth.TenantScope import tech.dokus.domain.model.auth.UpdateProfileRequest import tech.dokus.foundation.backend.database.now import tech.dokus.foundation.backend.security.JwtGenerator import tech.dokus.foundation.backend.security.TokenBlacklistService import tech.dokus.foundation.backend.utils.loggerFor import com.auth0.jwt.JWT import kotlin.time.Duration.Companion.days import kotlin.uuid.ExperimentalUuidApi</ID>
    <ID>ImportOrdering:AvatarRoutes.kt$import tech.dokus.database.repository.auth.TenantRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.model.AvatarUploadResponse import tech.dokus.domain.routes.Tenants import io.ktor.http.HttpStatusCode import io.ktor.http.content.PartData import io.ktor.http.content.forEachPart import io.ktor.http.content.streamProvider import io.ktor.server.request.receiveMultipart import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.post import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import tech.dokus.foundation.backend.storage.AvatarStorageService import tech.dokus.foundation.backend.utils.loggerFor</ID>
    <ID>ImportOrdering:BackgroundWorkers.kt$import tech.dokus.foundation.backend.cache.RedisClient import tech.dokus.foundation.backend.config.AppBaseConfig import tech.dokus.foundation.backend.utils.loggerFor import io.ktor.server.application.Application import io.ktor.server.application.ApplicationStarted import io.ktor.server.application.ApplicationStopping import kotlinx.coroutines.runBlocking import org.koin.ktor.ext.getKoin import org.koin.ktor.ext.inject import tech.dokus.backend.worker.DocumentProcessingWorker import tech.dokus.backend.worker.RateLimitCleanupWorker</ID>
    <ID>ImportOrdering:BankingRoutes.kt$import tech.dokus.foundation.backend.utils.loggerFor import io.ktor.server.application.Application import io.ktor.server.routing.routing</ID>
    <ID>ImportOrdering:InboundInvoiceRoutes.kt$import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.InboundInvoiceId import tech.dokus.domain.model.CreateInboundInvoiceRequest import tech.dokus.domain.model.MarkInboundInvoicePaidRequest import tech.dokus.domain.model.UpdatePayableInvoiceStatusRequest import tech.dokus.domain.routes.Inbound Invoices import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.patch import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.cashflow.InboundInvoiceService import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid</ID>
    <ID>ImportOrdering:InboundInvoiceService.kt$import tech.dokus.database.repository.cashflow.InboundInvoiceRepository import tech.dokus.database.repository.cashflow.InboundInvoiceStatistics import tech.dokus.domain.Money import tech.dokus.domain.VatRate import tech.dokus.domain.enums.PayableInvoiceStatus import tech.dokus.domain.enums.ExpenseCategory import tech.dokus.domain.ids.InboundInvoiceId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.model.CreateInboundInvoiceRequest import tech.dokus.domain.model.FinancialDocumentDto import tech.dokus.domain.model.MarkInboundInvoicePaidRequest import tech.dokus.domain.model.common.PaginatedResponse import tech.dokus.foundation.backend.utils.loggerFor import tech.dokus.peppol.model.PeppolReceivedDocument import kotlinx.datetime.LocalDate</ID>
    <ID>ImportOrdering:CashflowDocumentRoutes.kt$import tech.dokus.database.repository.cashflow.CashflowRepository import io.ktor.http.HttpStatusCode import io.ktor.server.resources.get import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import org.slf4j.LoggerFactory import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.routes.Cashflow import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal</ID>
    <ID>ImportOrdering:CashflowOverviewRoutes.kt$import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.routes.Cashflow import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.resources.get import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.cashflow.CashflowOverviewService</ID>
    <ID>ImportOrdering:CashflowOverviewService.kt$import tech.dokus.database.repository.cashflow.InboundInvoiceRepository import tech.dokus.database.repository.cashflow.ExpenseRepository import tech.dokus.database.repository.cashflow.InvoiceRepository import tech.dokus.domain.Money import tech.dokus.domain.enums.Currency import tech.dokus.domain.enums.InvoiceStatus import tech.dokus.domain.ids.TenantId import tech.dokus.domain.model.CashInSummary import tech.dokus.domain.model.CashOutSummary import tech.dokus.domain.model.CashflowOverview import tech.dokus.domain.model.CashflowPeriod import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.datetime.Clock import kotlinx.datetime.DatePeriod import kotlinx.datetime.LocalDate import kotlinx.datetime.TimeZone import kotlinx.datetime.minus import kotlinx.datetime.todayIn</ID>
    <ID>ImportOrdering:ChatRoutes.kt$import tech.dokus.ai.agents.ChatAgent import tech.dokus.ai.agents.ConversationMessage import tech.dokus.ai.config.AIProviderFactory import tech.dokus.foundation.backend.config.AIConfig import tech.dokus.foundation.backend.config.ModelPurpose import tech.dokus.ai.services.EmbeddingService import tech.dokus.ai.services.RAGService import tech.dokus.database.repository.cashflow.DocumentRepository import tech.dokus.domain.repository.ChatRepository import tech.dokus.domain.repository.ChunkRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.DocumentId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.ids.UserId import tech.dokus.domain.model.ai.ChatCitation import tech.dokus.domain.model.ai.ChatConfiguration import tech.dokus.domain.model.ai.ChatHistoryResponse import tech.dokus.domain.model.ai.ChatMessageDto import tech.dokus.domain.model.ai.ChatMessageId import tech.dokus.domain.model.ai.ChatRequest import tech.dokus.domain.model.ai.ChatResponse import tech.dokus.domain.model.ai.ChatResponseMetadata import tech.dokus.domain.model.ai.ChatScope import tech.dokus.domain.model.ai.ChatSessionId import tech.dokus.domain.model.ai.ChatSessionListResponse import tech.dokus.domain.model.ai.MessageRole import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.client.HttpClient import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.response.respond import io.ktor.server.routing.Route import io.ktor.server.routing.get import io.ktor.server.routing.post import kotlinx.datetime.Clock import kotlinx.datetime.TimeZone import kotlinx.datetime.toLocalDateTime import org.koin.ktor.ext.inject import org.slf4j.LoggerFactory import tech.dokus.ai.agents.MessageRole as AgentMessageRole</ID>
    <ID>ImportOrdering:CommonRoutes.kt$import tech.dokus.foundation.backend.config.AppBaseConfig import tech.dokus.foundation.backend.routes.healthRoutes import tech.dokus.foundation.backend.routes.serverInfoRoutes import io.ktor.server.application.Application import io.ktor.server.routing.routing</ID>
    <ID>ImportOrdering:ContactNoteService.kt$import tech.dokus.database.repository.contacts.ContactNoteRepository import tech.dokus.domain.ids.ContactId import tech.dokus.domain.ids.ContactNoteId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.ids.UserId import tech.dokus.domain.model.contact.ContactNoteDto import tech.dokus.domain.model.common.PaginatedResponse import tech.dokus.foundation.backend.utils.loggerFor</ID>
    <ID>ImportOrdering:ContactRoutes.kt$import tech.dokus.database.repository.contacts.ContactRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.ContactId import tech.dokus.domain.ids.ContactNoteId import tech.dokus.domain.model.contact.CreateContactNoteRequest import tech.dokus.domain.model.contact.CreateContactRequest import tech.dokus.domain.model.contact.UpdateContactNoteRequest import tech.dokus.domain.model.contact.UpdateContactPeppolRequest import tech.dokus.domain.model.contact.UpdateContactRequest import tech.dokus.domain.routes.Contacts import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.patch import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.contacts.ContactNoteService import tech.dokus.backend.services.contacts.ContactService</ID>
    <ID>ImportOrdering:ContactService.kt$import tech.dokus.database.repository.contacts.ContactRepository import tech.dokus.domain.ids.ContactId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.model.contact.ContactDto import tech.dokus.domain.model.contact.ContactStats import tech.dokus.domain.model.contact.CreateContactRequest import tech.dokus.domain.model.common.PaginatedResponse import tech.dokus.domain.model.contact.UpdateContactRequest import tech.dokus.foundation.backend.utils.loggerFor</ID>
    <ID>ImportOrdering:Database.kt$import tech.dokus.foundation.backend.database.DatabaseFactory import tech.dokus.foundation.backend.utils.loggerFor import io.ktor.server.application.Application import kotlinx.coroutines.runBlocking import org.koin.ktor.ext.inject</ID>
    <ID>ImportOrdering:DependencyInjection.kt$import tech.dokus.foundation.backend.config.AIConfig import tech.dokus.database.di.repositoryModules import tech.dokus.database.repository.auth.PasswordResetTokenRepository import tech.dokus.database.repository.auth.RefreshTokenRepository import tech.dokus.database.repository.auth.UserRepository import tech.dokus.database.DokusSchema import tech.dokus.domain.repository.ChunkRepository import tech.dokus.peppol.config.PeppolModuleConfig import tech.dokus.peppol.mapper.PeppolMapper import tech.dokus.peppol.provider.PeppolProviderFactory import tech.dokus.peppol.provider.client.RecommandCompaniesClient import tech.dokus.peppol.service.PeppolConnectionService import tech.dokus.peppol.service.PeppolService import tech.dokus.peppol.validator.PeppolValidator import io.ktor.client.HttpClient import io.ktor.client.engine.cio.CIO import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.logging.LogLevel import io.ktor.client.plugins.logging.Logging import io.ktor.serialization.kotlinx.json.json import io.ktor.server.application.Application import io.ktor.server.application.install import kotlinx.coroutines.runBlocking import kotlinx.serialization.json.Json import org.koin.core.module.dsl.singleOf import org.koin.dsl.bind import org.koin.dsl.module import org.koin.ktor.plugin.Koin import org.slf4j.LoggerFactory import tech.dokus.ai.service.AIService import tech.dokus.ai.services.ChunkingService import tech.dokus.ai.services.EmbeddingService import tech.dokus.ocr.OcrEngine import tech.dokus.ocr.engine.TesseractOcrEngine import tech.dokus.backend.services.auth.AuthService import tech.dokus.backend.services.auth.DisabledEmailService import tech.dokus.backend.services.auth.EmailConfig import tech.dokus.backend.services.auth.EmailService import tech.dokus.backend.services.auth.EmailVerificationService import tech.dokus.backend.services.auth.PasswordResetService import tech.dokus.backend.services.auth.RateLimitServiceInterface import tech.dokus.backend.services.auth.RedisRateLimitService import tech.dokus.backend.services.auth.SmtpEmailService import tech.dokus.backend.services.auth.TeamService import tech.dokus.backend.services.cashflow.InboundInvoiceService import tech.dokus.backend.services.cashflow.CashflowOverviewService import tech.dokus.backend.services.cashflow.ExpenseService import tech.dokus.backend.services.cashflow.InvoiceService import tech.dokus.backend.services.pdf.PdfPreviewService import tech.dokus.backend.services.contacts.ContactMatchingService import tech.dokus.backend.services.contacts.ContactNoteService import tech.dokus.backend.services.contacts.ContactService import tech.dokus.backend.worker.DocumentProcessingWorker import tech.dokus.backend.worker.RateLimitCleanupWorker import tech.dokus.foundation.backend.cache.RedisClient import tech.dokus.foundation.backend.cache.RedisNamespace import tech.dokus.foundation.backend.cache.redis import tech.dokus.foundation.backend.config.AppBaseConfig import tech.dokus.foundation.backend.config.MinioConfig import tech.dokus.foundation.backend.crypto.AesGcmCredentialCryptoService import tech.dokus.foundation.backend.crypto.CredentialCryptoService import tech.dokus.foundation.backend.crypto.PasswordCryptoService import tech.dokus.foundation.backend.crypto.PasswordCryptoService4j import tech.dokus.foundation.backend.database.DatabaseFactory import tech.dokus.foundation.backend.lookup.CbeApiClient import tech.dokus.foundation.backend.security.JwtGenerator import tech.dokus.foundation.backend.security.JwtValidator import tech.dokus.foundation.backend.security.RedisTokenBlacklistService import tech.dokus.foundation.backend.security.TokenBlacklistService import tech.dokus.foundation.backend.storage.AvatarStorageService import tech.dokus.foundation.backend.storage.DocumentStorageService import tech.dokus.foundation.backend.storage.DocumentUploadValidator import tech.dokus.foundation.backend.storage.MinioStorage import tech.dokus.foundation.backend.storage.ObjectStorage</ID>
    <ID>ImportOrdering:DocumentPageRoutes.kt$import tech.dokus.database.repository.cashflow.DocumentRepository import io.ktor.http.ContentType import io.ktor.http.HttpStatusCode import io.ktor.server.resources.get import io.ktor.server.response.respond import io.ktor.server.response.respondBytes import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import org.slf4j.LoggerFactory import tech.dokus.backend.services.pdf.PdfPreviewService import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.DocumentId import tech.dokus.domain.routes.Documents import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal</ID>
    <ID>ImportOrdering:DocumentUploadRoutes.kt$import tech.dokus.database.repository.cashflow.DocumentIngestionRunRepository import tech.dokus.database.repository.cashflow.DocumentRepository import tech.dokus.database.repository.cashflow.IngestionRunSummary import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.model.DocumentIngestionDto import tech.dokus.domain.model.DocumentRecordDto import tech.dokus.domain.routes.Documents import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import tech.dokus.foundation.backend.storage.DocumentUploadValidator import tech.dokus.foundation.backend.storage.DocumentStorageService as MinioDocumentStorageService import io.ktor.http.* import io.ktor.http.content.* import io.ktor.server.request.* import io.ktor.server.resources.post import io.ktor.server.response.* import io.ktor.server.routing.* import org.koin.ktor.ext.inject import org.slf4j.LoggerFactory</ID>
    <ID>ImportOrdering:EmailConfig.kt$import tech.dokus.foundation.backend.config.AppBaseConfig import com.typesafe.config.Config</ID>
    <ID>ImportOrdering:EmailVerificationService.kt$import tech.dokus.database.repository.auth.UserRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.UserId import tech.dokus.foundation.backend.database.now import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch import java.security.SecureRandom import java.util.Base64 import kotlin.time.Duration.Companion.hours import kotlin.uuid.ExperimentalUuidApi</ID>
    <ID>ImportOrdering:ExpenseRoutes.kt$import tech.dokus.domain.enums.ExpenseCategory import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.ExpenseId import tech.dokus.domain.model.CreateExpenseRequest import tech.dokus.domain.routes.Expenses import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.cashflow.ExpenseService import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid</ID>
    <ID>ImportOrdering:ExpenseService.kt$import tech.dokus.database.repository.cashflow.ExpenseRepository import tech.dokus.domain.enums.ExpenseCategory import tech.dokus.domain.ids.ExpenseId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.model.CreateExpenseRequest import tech.dokus.domain.model.FinancialDocumentDto import tech.dokus.domain.model.common.PaginatedResponse import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.datetime.LocalDate</ID>
    <ID>ImportOrdering:IdentityRoutes.kt$import tech.dokus.domain.Email import tech.dokus.domain.model.auth.LoginRequest import tech.dokus.domain.model.auth.RefreshTokenRequest import tech.dokus.domain.model.auth.RegisterRequest import tech.dokus.domain.model.auth.ResetPasswordRequest import tech.dokus.domain.routes.Identity import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.patch import io.ktor.server.resources.post import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.auth.AuthService</ID>
    <ID>ImportOrdering:InvoiceNumberConcurrencyTest.kt$import tech.dokus.database.repository.cashflow.InvoiceNumberRepository import tech.dokus.database.services.InvoiceNumberGenerator import tech.dokus.database.tables.auth.TenantSettingsTable import tech.dokus.database.tables.auth.TenantTable import tech.dokus.database.tables.cashflow.InvoiceNumberSequencesTable import tech.dokus.domain.enums.Language import tech.dokus.domain.enums.TenantPlan import tech.dokus.domain.enums.TenantStatus import tech.dokus.domain.enums.TenantType import tech.dokus.domain.ids.TenantId import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.async import kotlinx.coroutines.awaitAll import kotlinx.coroutines.runBlocking import org.jetbrains.exposed.v1.jdbc.Database import org.jetbrains.exposed.v1.jdbc.SchemaUtils import org.jetbrains.exposed.v1.jdbc.insert import org.jetbrains.exposed.v1.jdbc.transactions.transaction import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test import java.math.BigDecimal import java.time.Year import java.util.UUID import java.util.concurrent.ConcurrentHashMap import kotlin.test.assertEquals import kotlin.test.assertTrue import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.toKotlinUuid</ID>
    <ID>ImportOrdering:InvoiceNumberYearRolloverTest.kt$import tech.dokus.database.repository.cashflow.InvoiceNumberRepository import tech.dokus.database.services.InvoiceNumberGenerator import tech.dokus.database.tables.auth.TenantSettingsTable import tech.dokus.database.tables.auth.TenantTable import tech.dokus.database.tables.cashflow.InvoiceNumberSequencesTable import tech.dokus.domain.enums.Language import tech.dokus.domain.enums.TenantPlan import tech.dokus.domain.enums.TenantStatus import tech.dokus.domain.enums.TenantType import tech.dokus.domain.ids.TenantId import kotlinx.coroutines.runBlocking import org.jetbrains.exposed.v1.jdbc.Database import org.jetbrains.exposed.v1.jdbc.SchemaUtils import org.jetbrains.exposed.v1.jdbc.insert import org.jetbrains.exposed.v1.jdbc.transactions.transaction import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test import java.math.BigDecimal import java.time.Year import java.util.UUID import kotlin.test.assertEquals import kotlin.test.assertTrue import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.toKotlinUuid</ID>
    <ID>ImportOrdering:InvoiceRoutes.kt$import tech.dokus.domain.enums.InvoiceStatus import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.InvoiceId import tech.dokus.domain.model.CreateInvoiceRequest import tech.dokus.domain.model.InvoiceItemDto import tech.dokus.domain.model.RecordPaymentRequest import tech.dokus.domain.routes.Invoices import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.request.receiveNullable import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.patch import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.cashflow.InvoiceService import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid</ID>
    <ID>ImportOrdering:InvoiceService.kt$import tech.dokus.database.repository.cashflow.InvoiceRepository import tech.dokus.domain.enums.InvoiceStatus import tech.dokus.domain.ids.InvoiceId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.model.CreateInvoiceRequest import tech.dokus.domain.model.FinancialDocumentDto import tech.dokus.domain.model.common.PaginatedResponse import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.datetime.LocalDate</ID>
    <ID>ImportOrdering:LookupRoutes.kt$import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.model.entity.EntityLookupResponse import tech.dokus.domain.routes.Lookup import tech.dokus.foundation.backend.lookup.CbeApiClient import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.utils.loggerFor import io.ktor.http.HttpStatusCode import io.ktor.server.resources.get import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject</ID>
    <ID>ImportOrdering:MultipartUpload.kt$import tech.dokus.domain.exceptions.DokusException import io.ktor.http.content.PartData import io.ktor.utils.io.readAvailable import java.io.ByteArrayOutputStream import kotlin.io.DEFAULT_BUFFER_SIZE</ID>
    <ID>ImportOrdering:PasswordResetService.kt$import tech.dokus.database.repository.auth.PasswordResetTokenRepository import tech.dokus.database.repository.auth.RefreshTokenRepository import tech.dokus.database.repository.auth.UserRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.UserId import tech.dokus.foundation.backend.database.now import tech.dokus.foundation.backend.security.TokenBlacklistService import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch import java.security.SecureRandom import java.util.Base64 import kotlin.time.Duration.Companion.hours import kotlin.uuid.ExperimentalUuidApi</ID>
    <ID>ImportOrdering:PaymentRoutes.kt$import tech.dokus.domain.routes.Payments import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import io.ktor.http.HttpStatusCode import io.ktor.server.resources.get import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.slf4j.LoggerFactory</ID>
    <ID>ImportOrdering:PeppolRoutes.kt$import tech.dokus.database.repository.auth.AddressRepository import tech.dokus.database.repository.auth.TenantRepository import tech.dokus.database.repository.contacts.ContactRepository import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.InvoiceId import tech.dokus.domain.model.PeppolConnectRequest import tech.dokus.domain.model.SavePeppolSettingsRequest import tech.dokus.domain.routes.Peppol import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import tech.dokus.peppol.service.PeppolConnectionService import tech.dokus.peppol.service.PeppolService import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import kotlinx.serialization.Serializable import org.koin.ktor.ext.inject import tech.dokus.backend.services.cashflow.InboundInvoiceService import tech.dokus.backend.services.cashflow.InvoiceService import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid</ID>
    <ID>ImportOrdering:RateLimitCleanupWorker.kt$import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.delay import kotlinx.coroutines.isActive import kotlinx.coroutines.launch import tech.dokus.backend.services.auth.RateLimitServiceInterface import kotlin.time.Duration.Companion.hours</ID>
    <ID>ImportOrdering:Routing.kt$import tech.dokus.foundation.backend.config.AppBaseConfig import io.ktor.server.application.Application import org.slf4j.LoggerFactory import tech.dokus.backend.routes.auth.configureAuthRoutes import tech.dokus.backend.routes.cashflow.configureCashflowRoutes import tech.dokus.backend.routes.common.configureCommonRoutes import tech.dokus.backend.routes.contacts.configureContactsRoutes import tech.dokus.backend.routes.payment.configurePaymentRoutes</ID>
    <ID>ImportOrdering:SmtpEmailService.kt$import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.coroutines.DelicateCoroutinesApi import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import java.util.Properties import javax.mail.Authenticator import javax.mail.Message import javax.mail.PasswordAuthentication import javax.mail.Session import javax.mail.Transport import javax.mail.internet.InternetAddress import javax.mail.internet.MimeBodyPart import javax.mail.internet.MimeMessage import javax.mail.internet.MimeMultipart</ID>
    <ID>ImportOrdering:TeamRoutes.kt$import tech.dokus.domain.enums.InvitationStatus import tech.dokus.domain.ids.InvitationId import tech.dokus.domain.ids.UserId import tech.dokus.domain.model.CreateInvitationRequest import tech.dokus.domain.model.TransferOwnershipRequest import tech.dokus.domain.model.UpdateMemberRoleRequest import tech.dokus.domain.routes.Team import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.delete import io.ktor.server.resources.get import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.backend.services.auth.TeamService import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid</ID>
    <ID>ImportOrdering:TeamService.kt$import tech.dokus.database.repository.auth.InvitationRepository import tech.dokus.database.repository.auth.TenantRepository import tech.dokus.database.repository.auth.UserRepository import tech.dokus.domain.enums.InvitationStatus import tech.dokus.domain.enums.UserRole import tech.dokus.domain.ids.InvitationId import tech.dokus.domain.ids.TenantId import tech.dokus.domain.ids.UserId import tech.dokus.domain.model.CreateInvitationRequest import tech.dokus.domain.model.TeamMember import tech.dokus.domain.model.TenantInvitation import tech.dokus.foundation.backend.utils.loggerFor import kotlinx.datetime.Clock import kotlinx.datetime.TimeZone import kotlin.time.Duration.Companion.days</ID>
    <ID>ImportOrdering:TenantRoutes.kt$import tech.dokus.database.repository.auth.AddressRepository import tech.dokus.database.repository.auth.TenantRepository import tech.dokus.database.repository.auth.UserRepository import tech.dokus.database.services.InvoiceNumberGenerator import tech.dokus.domain.enums.UserRole import tech.dokus.domain.exceptions.DokusException import tech.dokus.domain.ids.TenantId import tech.dokus.domain.model.CreateTenantRequest import tech.dokus.domain.model.InvoiceNumberPreviewResponse import tech.dokus.domain.model.TenantSettings import tech.dokus.domain.model.UpsertTenantAddressRequest import tech.dokus.domain.routes.Tenants import io.ktor.http.HttpStatusCode import io.ktor.server.request.receive import io.ktor.server.resources.get import io.ktor.server.resources.post import io.ktor.server.resources.put import io.ktor.server.response.respond import io.ktor.server.routing.Route import org.koin.ktor.ext.inject import tech.dokus.foundation.backend.security.authenticateJwt import tech.dokus.foundation.backend.security.dokusPrincipal import tech.dokus.foundation.backend.storage.AvatarStorageService import tech.dokus.foundation.backend.utils.loggerFor import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid</ID>
    <ID>Indentation:InboundInvoiceService.kt$InboundInvoiceService$ </ID>
    <ID>Indentation:ChatRoutes.kt$ </ID>
    <ID>Indentation:ContactEnrichmentService.kt$ContactEnrichmentService$ </ID>
    <ID>Indentation:ContactRoutes.kt$ </ID>
    <ID>Indentation:DocumentProcessingWorker.kt$DocumentProcessingWorker$ </ID>
    <ID>Indentation:DocumentRecordRoutes.kt$ </ID>
    <ID>Indentation:ExpenseService.kt$ExpenseService$ </ID>
    <ID>Indentation:PeppolRoutes.kt$ </ID>
    <ID>Indentation:SmtpEmailService.kt$SmtpEmailService$ </ID>
    <ID>LongMethod:AttachmentRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.attachmentRoutes()</ID>
    <ID>LongMethod:AvatarRoutes.kt$internal fun Route.avatarRoutes()</ID>
    <ID>LongMethod:InboundInvoiceRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.inboundInvoiceRoutes()</ID>
    <ID>LongMethod:CashflowOverviewService.kt$CashflowOverviewService$suspend fun getCashflowOverview( tenantId: TenantId, fromDate: LocalDate? = null, toDate: LocalDate? = null ): Result&lt;CashflowOverview></ID>
    <ID>LongMethod:ChatRoutes.kt$internal fun Route.chatRoutes()</ID>
    <ID>LongMethod:ChatRoutes.kt$private suspend fun processChat( request: ChatRequest, tenantId: TenantId, userId: UserId, documentId: DocumentId?, chatAgent: ChatAgent, chatRepository: ChatRepository, aiConfig: AIConfig, logger: org.slf4j.Logger ): ChatResponse</ID>
    <ID>LongMethod:ContactEnrichmentService.kt$ContactEnrichmentService$private fun calculateEnrichmentFields( contact: ContactDto, data: EnrichmentData ): Pair&lt;List&lt;Pair&lt;String, String>>, List&lt;String>></ID>
    <ID>LongMethod:ContactMatchingService.kt$ContactMatchingService$suspend fun findMatch( tenantId: TenantId, extracted: ExtractedCounterparty ): Result&lt;ContactSuggestion></ID>
    <ID>LongMethod:ContactRoutes.kt$fun Route.contactRoutes()</ID>
    <ID>LongMethod:DocumentPageRoutes.kt$internal fun Route.documentPageRoutes()</ID>
    <ID>LongMethod:DocumentProcessingWorker.kt$DocumentProcessingWorker$private suspend fun chunkAndEmbedDocument( tenantId: String, documentId: String, rawText: String ): Int</ID>
    <ID>LongMethod:DocumentProcessingWorker.kt$DocumentProcessingWorker$private suspend fun processIngestionRun(ingestion: IngestionItemEntity)</ID>
    <ID>LongMethod:DocumentRecordRoutes.kt$internal fun Route.documentRecordRoutes()</ID>
    <ID>LongMethod:DocumentUploadRoutes.kt$internal fun Route.documentUploadRoutes()</ID>
    <ID>LongMethod:InvoiceRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.invoiceRoutes()</ID>
    <ID>LongMethod:PeppolRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.peppolRoutes()</ID>
    <ID>LongMethod:TeamRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.teamRoutes()</ID>
    <ID>LongMethod:TenantRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.tenantRoutes()</ID>
    <ID>LongParameterList:AuthService.kt$AuthService$( private val userRepository: UserRepository, private val jwtGenerator: JwtGenerator, private val refreshTokenRepository: RefreshTokenRepository, private val rateLimitService: RateLimitServiceInterface, private val emailVerificationService: EmailVerificationService, private val passwordResetService: PasswordResetService, private val tokenBlacklistService: TokenBlacklistService? = null, private val maxConcurrentSessions: Int = DEFAULT_MAX_CONCURRENT_SESSIONS )</ID>
    <ID>LongParameterList:InboundInvoiceService.kt$InboundInvoiceService$( tenantId: TenantId, status: PayableInvoiceStatus? = null, category: ExpenseCategory? = null, fromDate: LocalDate? = null, toDate: LocalDate? = null, limit: Int = 50, offset: Int = 0 )</ID>
    <ID>LongParameterList:ChatRoutes.kt$( request: ChatRequest, tenantId: TenantId, userId: UserId, documentId: DocumentId?, chatAgent: ChatAgent, chatRepository: ChatRepository, aiConfig: AIConfig, logger: org.slf4j.Logger )</ID>
    <ID>LongParameterList:ContactService.kt$ContactService$( tenantId: TenantId, isActive: Boolean? = null, peppolEnabled: Boolean? = null, searchQuery: String? = null, limit: Int = 50, offset: Int = 0 )</ID>
    <ID>LongParameterList:DocumentProcessingWorker.kt$DocumentProcessingWorker$( private val ingestionRepository: ProcessorIngestionRepository, private val documentStorage: DocumentStorageService, private val aiService: AIService, private val ocrEngine: OcrEngine, private val config: ProcessorConfig, // Optional RAG dependencies - if provided, chunking and embedding will be performed private val chunkingService: ChunkingService? = null, private val embeddingService: EmbeddingService? = null, private val chunkRepository: ChunkRepository? = null )</ID>
    <ID>LongParameterList:DocumentRecordRoutes.kt$( documentId: DocumentId, documentType: DocumentType?, tenantId: tech.dokus.domain.ids.TenantId, invoiceRepository: InvoiceRepository, inboundInvoiceRepository: InboundInvoiceRepository, expenseRepository: ExpenseRepository )</ID>
    <ID>LongParameterList:ExpenseService.kt$ExpenseService$( tenantId: TenantId, category: ExpenseCategory? = null, fromDate: LocalDate? = null, toDate: LocalDate? = null, limit: Int = 50, offset: Int = 0 )</ID>
    <ID>LongParameterList:InvoiceService.kt$InvoiceService$( tenantId: TenantId, status: InvoiceStatus? = null, fromDate: LocalDate? = null, toDate: LocalDate? = null, limit: Int = 50, offset: Int = 0 )</ID>
    <ID>LoopWithTooManyJumpStatements:TenantRoutes.kt$for</ID>
    <ID>MagicNumber:Application.kt$10000</ID>
    <ID>MagicNumber:Application.kt$5000</ID>
    <ID>MagicNumber:AuthService.kt$AuthService$8</ID>
    <ID>MagicNumber:InboundInvoiceRoutes.kt$200</ID>
    <ID>MagicNumber:InboundInvoiceService.kt$InboundInvoiceService$10</ID>
    <ID>MagicNumber:InboundInvoiceService.kt$InboundInvoiceService$100.0</ID>
    <ID>MagicNumber:CashflowDocumentRoutes.kt$200</ID>
    <ID>MagicNumber:ChatRoutes.kt$100</ID>
    <ID>MagicNumber:ChatRoutes.kt$20</ID>
    <ID>MagicNumber:ChatRoutes.kt$50</ID>
    <ID>MagicNumber:ContactMatchingService.kt$ContactMatchingService$0.25f</ID>
    <ID>MagicNumber:ContactMatchingService.kt$ContactMatchingService$0.5f</ID>
    <ID>MagicNumber:ContactMatchingService.kt$ContactMatchingService$0.8f</ID>
    <ID>MagicNumber:ContactMatchingService.kt$ContactMatchingService$0.9f</ID>
    <ID>MagicNumber:ContactRoutes.kt$200</ID>
    <ID>MagicNumber:DependencyInjection.kt$120_000</ID>
    <ID>MagicNumber:DisabledEmailService.kt$DisabledEmailService$20</ID>
    <ID>MagicNumber:DocumentRecordRoutes.kt$100</ID>
    <ID>MagicNumber:EmailVerificationService.kt$EmailVerificationService$3</ID>
    <ID>MagicNumber:EmailVerificationService.kt$EmailVerificationService$32</ID>
    <ID>MagicNumber:ExpenseRoutes.kt$200</ID>
    <ID>MagicNumber:InvoiceRoutes.kt$200</ID>
    <ID>MagicNumber:LookupRoutes.kt$3</ID>
    <ID>MagicNumber:MultipartUpload.kt$1024.0</ID>
    <ID>MagicNumber:PasswordResetService.kt$PasswordResetService$10</ID>
    <ID>MagicNumber:PasswordResetService.kt$PasswordResetService$3</ID>
    <ID>MagicNumber:PasswordResetService.kt$PasswordResetService$32</ID>
    <ID>MagicNumber:PeppolRoutes.kt$200</ID>
    <ID>MagicNumber:SmtpEmailService.kt$SmtpEmailService$3</ID>
    <ID>MaxLineLength:AttachmentRoutes.kt$val (fileBytes, filename, contentType) = handleMultipartUpload(DocumentUploadValidator.DEFAULT_MAX_FILE_SIZE_BYTES)</ID>
    <ID>MaxLineLength:AuthService.kt$AuthService$logger.info("User ${userId.value} at session limit ($activeSessions/$maxConcurrentSessions), revoking oldest session")</ID>
    <ID>MaxLineLength:InboundInvoiceService.kt$InboundInvoiceService$lowerName.contains("consultant")</ID>
    <ID>MaxLineLength:CashflowDocumentRoutes.kt$logger.info("Fetched ${it.items.size} cashflow documents (offset=${route.offset}, limit=${route.limit}, total=${it.total})")</ID>
    <ID>MaxLineLength:CashflowOverviewService.kt$CashflowOverviewService$logger.info("Calculating cashflow overview for tenant: $tenantId (from=$effectiveFromDate, to=$effectiveToDate)")</ID>
    <ID>MaxLineLength:ContactRoutes.kt$)</ID>
    <ID>MaxLineLength:ContactService.kt$ContactService$logger.debug("Listing contacts for tenant: $tenantId (isActive=$isActive, peppolEnabled=$peppolEnabled, limit=$limit, offset=$offset)")</ID>
    <ID>MaxLineLength:DocumentProcessingWorker.kt$DocumentProcessingWorker$logger.info("Deleted $deletedCount old chunks for document $documentId (old hash=$existingHash, new hash=$contentHash)")</ID>
    <ID>MaxLineLength:DocumentProcessingWorker.kt$DocumentProcessingWorker$logger.info("Starting document processing worker (interval=${config.pollingInterval}ms, batch=${config.batchSize}, RAG=${isRagEnabled})")</ID>
    <ID>MaxLineLength:DocumentProcessingWorker.kt$DocumentProcessingWorker$logger.info("Stored ${chunksWithEmbeddings.size} chunks with embeddings for document $documentId (hash=$contentHash)")</ID>
    <ID>MaxLineLength:DocumentProcessingWorker.kt$DocumentProcessingWorker$throw IllegalStateException("Embedding count mismatch: expected ${chunkingResult.chunks.size}, got ${embeddings.size}")</ID>
    <ID>MaxLineLength:DocumentRecordRoutes.kt$throw DokusException.BadRequest("Invoice creation from document requires contact selection. Use /api/v1/invoices instead.")</ID>
    <ID>MaxLineLength:InvoiceNumberConcurrencyTest.kt$InvoiceNumberConcurrencyTest$assertEquals((1..numberOfRequests).toList(), results.sorted(), "Numbers should be sequential 1-$numberOfRequests")</ID>
    <ID>MaxLineLength:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$url = "jdbc:h2:mem:test_rollover_${System.currentTimeMillis()};MODE=PostgreSQL;DB_CLOSE_DELAY=-1;LOCK_TIMEOUT=10000"</ID>
    <ID>MaxLineLength:PeppolRoutes.kt$*</ID>
    <ID>MaxLineLength:RedisRateLimitService.kt$RedisRateLimitService$message = "Too many login attempts. Please try again in ${lockoutDuration.inWholeMinutes} minutes."</ID>
    <ID>MaxLineLength:SmtpEmailService.kt$SmtpEmailService$logger.info("SMTP Email Service initialized (host: ${config.smtp.host}, port: ${config.smtp.port}, TLS: ${config.smtp.enableTls})")</ID>
    <ID>MaximumLineLength:AttachmentRoutes.kt$ </ID>
    <ID>MaximumLineLength:AuthService.kt$AuthService$ </ID>
    <ID>MaximumLineLength:InboundInvoiceService.kt$InboundInvoiceService$ </ID>
    <ID>MaximumLineLength:CashflowDocumentRoutes.kt$ </ID>
    <ID>MaximumLineLength:CashflowOverviewService.kt$CashflowOverviewService$ </ID>
    <ID>MaximumLineLength:ContactRoutes.kt$ </ID>
    <ID>MaximumLineLength:ContactService.kt$ContactService$ </ID>
    <ID>MaximumLineLength:DocumentProcessingWorker.kt$DocumentProcessingWorker$ </ID>
    <ID>MaximumLineLength:DocumentRecordRoutes.kt$ </ID>
    <ID>MaximumLineLength:InvoiceNumberConcurrencyTest.kt$InvoiceNumberConcurrencyTest$ </ID>
    <ID>MaximumLineLength:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$ </ID>
    <ID>MaximumLineLength:RedisRateLimitService.kt$RedisRateLimitService$ </ID>
    <ID>MaximumLineLength:SmtpEmailService.kt$SmtpEmailService$ </ID>
    <ID>MultiLineIfElse:DocumentRecordRoutes.kt$null</ID>
    <ID>MultiLineIfElse:EmailConfig.kt$EmailConfig.Companion$10000L</ID>
    <ID>MultiLineIfElse:EmailConfig.kt$EmailConfig.Companion$null</ID>
    <ID>MultiLineIfElse:EmailConfig.kt$EmailConfig.Companion$smtpConfig.getLong("connectionTimeout")</ID>
    <ID>MultiLineIfElse:EmailConfig.kt$EmailConfig.Companion$smtpConfig.getLong("timeout")</ID>
    <ID>MultiLineIfElse:TenantRoutes.kt$null</ID>
    <ID>NewLineAtEndOfFile:RateLimitCleanupWorker.kt$tech.dokus.backend.worker.RateLimitCleanupWorker.kt</ID>
    <ID>NoBlankLineBeforeRbrace:DocumentProcessingWorker.kt$DocumentProcessingWorker$ </ID>
    <ID>NoConsecutiveBlankLines:MultipartUpload.kt$ </ID>
    <ID>NoEmptyFirstLineInMethodBlock:ChatRoutes.kt$ </ID>
    <ID>NoEmptyFirstLineInMethodBlock:TeamRoutes.kt$ </ID>
    <ID>NoMultipleSpaces:DocumentUploadRoutes.kt$ </ID>
    <ID>NoWildcardImports:DocumentUploadRoutes.kt$import io.ktor.http.*</ID>
    <ID>NoWildcardImports:DocumentUploadRoutes.kt$import io.ktor.http.content.*</ID>
    <ID>NoWildcardImports:DocumentUploadRoutes.kt$import io.ktor.server.request.*</ID>
    <ID>NoWildcardImports:DocumentUploadRoutes.kt$import io.ktor.server.response.*</ID>
    <ID>NoWildcardImports:DocumentUploadRoutes.kt$import io.ktor.server.routing.*</ID>
    <ID>ReturnCount:AuthService.kt$AuthService$private fun resolveTenantScope( memberships: List&lt;TenantMembership>, selectedTenantId: TenantId? = null ): TenantScope?</ID>
    <ID>ReturnCount:DocumentProcessingWorker.kt$DocumentProcessingWorker$private suspend fun chunkAndEmbedDocument( tenantId: String, documentId: String, rawText: String ): Int</ID>
    <ID>ReturnCount:DocumentProcessingWorker.kt$DocumentProcessingWorker$private suspend fun processIngestionRun(ingestion: IngestionItemEntity)</ID>
    <ID>ReturnCount:EmailVerificationService.kt$EmailVerificationService$suspend fun resendVerificationEmail(userId: UserId): Result&lt;Unit></ID>
    <ID>ReturnCount:EmailVerificationService.kt$EmailVerificationService$suspend fun verifyEmail(token: String): Result&lt;Unit></ID>
    <ID>ReturnCount:PasswordResetService.kt$PasswordResetService$suspend fun resetPassword(token: String, newPassword: String): Result&lt;Unit></ID>
    <ID>ReturnCount:RedisRateLimitService.kt$RedisRateLimitService$override suspend fun checkLoginAttempts(email: String): Result&lt;Unit></ID>
    <ID>SpreadOperator:RedisRateLimitService.kt$RedisRateLimitService$(*attemptKeys.toTypedArray())</ID>
    <ID>StringTemplate:DocumentProcessingWorker.kt$DocumentProcessingWorker$${isRagEnabled}</ID>
    <ID>SwallowedException:AttachmentRoutes.kt$e: Exception</ID>
    <ID>SwallowedException:AvatarRoutes.kt$e: IllegalArgumentException</ID>
    <ID>SwallowedException:ChatRoutes.kt$e: Exception</ID>
    <ID>SwallowedException:DocumentPageRoutes.kt$e: Exception</ID>
    <ID>SwallowedException:DocumentPageRoutes.kt$e: IllegalArgumentException</ID>
    <ID>SwallowedException:DocumentRecordRoutes.kt$e: Exception</ID>
    <ID>SwallowedException:InvoiceNumberConcurrencyTest.kt$InvoiceNumberConcurrencyTest$e: Throwable</ID>
    <ID>ThrowsCount:AttachmentRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.attachmentRoutes()</ID>
    <ID>ThrowsCount:AvatarRoutes.kt$internal fun Route.avatarRoutes()</ID>
    <ID>ThrowsCount:InboundInvoiceRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.inboundInvoiceRoutes()</ID>
    <ID>ThrowsCount:CashflowDocumentRoutes.kt$internal fun Route.cashflowDocumentRoutes()</ID>
    <ID>ThrowsCount:ChatRoutes.kt$internal fun Route.chatRoutes()</ID>
    <ID>ThrowsCount:ContactRoutes.kt$fun Route.contactRoutes()</ID>
    <ID>ThrowsCount:DocumentPageRoutes.kt$internal fun Route.documentPageRoutes()</ID>
    <ID>ThrowsCount:DocumentProcessingWorker.kt$DocumentProcessingWorker$private suspend fun chunkAndEmbedDocument( tenantId: String, documentId: String, rawText: String ): Int</ID>
    <ID>ThrowsCount:DocumentRecordRoutes.kt$internal fun Route.documentRecordRoutes()</ID>
    <ID>ThrowsCount:DocumentUploadRoutes.kt$internal fun Route.documentUploadRoutes()</ID>
    <ID>ThrowsCount:ExpenseRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.expenseRoutes()</ID>
    <ID>ThrowsCount:InvoiceRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.invoiceRoutes()</ID>
    <ID>ThrowsCount:PeppolRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.peppolRoutes()</ID>
    <ID>ThrowsCount:TenantRoutes.kt$@OptIn(ExperimentalUuidApi::class) internal fun Route.tenantRoutes()</ID>
    <ID>TooGenericExceptionCaught:AttachmentRoutes.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AuthService.kt$AuthService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AvatarRoutes.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InboundInvoiceService.kt$InboundInvoiceService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ChatRoutes.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DocumentPageRoutes.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DocumentProcessingWorker.kt$DocumentProcessingWorker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DocumentRecordRoutes.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EmailVerificationService.kt$EmailVerificationService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PasswordResetService.kt$PasswordResetService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PdfPreviewService.kt$PdfPreviewService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RateLimitCleanupWorker.kt$RateLimitCleanupWorker$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RedisRateLimitService.kt$RedisRateLimitService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SmtpEmailService.kt$SmtpEmailService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TenantRoutes.kt$e: Exception</ID>
    <ID>TooManyFunctions:AuthService.kt$AuthService</ID>
    <ID>TooManyFunctions:InboundInvoiceService.kt$InboundInvoiceService</ID>
    <ID>TooManyFunctions:ContactService.kt$ContactService</ID>
    <ID>TooManyFunctions:SmtpEmailService.kt$SmtpEmailService : EmailService</ID>
    <ID>UnusedParameter:BackgroundWorkers.kt$appConfig: AppBaseConfig</ID>
    <ID>UnusedParameter:PdfPreviewService.kt$PdfPreviewService$tenantId: TenantId</ID>
    <ID>UnusedParameter:TeamService.kt$TeamService$requestingUserId: UserId</ID>
    <ID>UnusedPrivateClass:ExpenseRoutes.kt$CategorizeExpenseRequest</ID>
    <ID>UnusedPrivateClass:ExpenseRoutes.kt$CategorizeExpenseResponse</ID>
    <ID>UnusedPrivateClass:InvoiceRoutes.kt$CalculateTotalsRequest</ID>
    <ID>UnusedPrivateProperty:DocumentRecordRoutes.kt$val invoiceData = extractedData.invoice ?: throw DokusException.BadRequest("No invoice data extracted from document")</ID>
    <ID>UnusedPrivateProperty:PdfPreviewService.kt$PdfPreviewService.Companion$private const val DEFAULT_DPI = 150</ID>
    <ID>UnusedPrivateProperty:PdfPreviewService.kt$PdfPreviewService.Companion$private const val DEFAULT_MAX_PAGES = 10</ID>
    <ID>UnusedPrivateProperty:RedisRateLimitService.kt$RedisRateLimitService$val windowStart = currentTime - attemptWindow.inWholeMilliseconds</ID>
    <ID>UnusedPrivateProperty:TeamService.kt$TeamService$private val tenantRepository: TenantRepository</ID>
    <ID>UseCheckOrError:DocumentProcessingWorker.kt$DocumentProcessingWorker$throw IllegalStateException("Embedding count mismatch: expected ${chunkingResult.chunks.size}, got ${embeddings.size}")</ID>
    <ID>UseCheckOrError:TeamService.kt$TeamService$throw IllegalStateException("Failed to retrieve created invitation")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Cannot change role to Owner. Use transfer ownership instead.")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Cannot change the Owner's role. Transfer ownership first.")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Cannot invite users as Owner. Use transfer ownership instead.")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Cannot remove the workspace Owner")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Cannot remove yourself from the workspace")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Only the Owner can transfer ownership")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("Target user's membership is not active")</ID>
    <ID>UseRequire:TeamService.kt$TeamService$throw IllegalArgumentException("User is already a member of this workspace")</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val formatted2024_1 = invoiceNumberGenerator.formatInvoiceNumber("INV", 2024, num2024_1, 4, true)</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val formatted2024_2 = invoiceNumberGenerator.formatInvoiceNumber("INV", 2024, num2024_2, 4, true)</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val formatted2025_1 = invoiceNumberGenerator.formatInvoiceNumber("INV", 2025, num2, 4, true)</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val formatted2025_1 = invoiceNumberGenerator.formatInvoiceNumber("INV", 2025, num2025_1, 4, true)</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val formatted2025_2 = invoiceNumberGenerator.formatInvoiceNumber("INV", 2025, num2025_2, 4, true)</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val formatted2025_2 = invoiceNumberGenerator.formatInvoiceNumber("INV", 2025, num3, 4, true)</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val num2024_1 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2024).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val num2024_2 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2024).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val num2025_1 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2025).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val num2025_2 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2025).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val tenant1_2024_1 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2024).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val tenant1_2024_2 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2024).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val tenant1_2025_1 = invoiceNumberRepository.getAndIncrementSequence(testTenantId!!, 2025).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val tenant2_2024_1 = invoiceNumberRepository.getAndIncrementSequence(secondTenantId, 2024).getOrThrow()</ID>
    <ID>VariableNaming:InvoiceNumberYearRolloverTest.kt$InvoiceNumberYearRolloverTest$val tenant2_2025_1 = invoiceNumberRepository.getAndIncrementSequence(secondTenantId, 2025).getOrThrow()</ID>
    <ID>WildcardImport:DocumentUploadRoutes.kt$import io.ktor.http.*</ID>
    <ID>WildcardImport:DocumentUploadRoutes.kt$import io.ktor.http.content.*</ID>
    <ID>WildcardImport:DocumentUploadRoutes.kt$import io.ktor.server.request.*</ID>
    <ID>WildcardImport:DocumentUploadRoutes.kt$import io.ktor.server.response.*</ID>
    <ID>WildcardImport:DocumentUploadRoutes.kt$import io.ktor.server.routing.*</ID>
    <ID>Wrapping:Application.kt$(</ID>
    <ID>Wrapping:DependencyInjection.kt$(</ID>
    <ID>Wrapping:DocumentRecordRoutes.kt$(</ID>
    <ID>Wrapping:PeppolRoutes.kt$(</ID>
    <ID>Wrapping:PeppolRoutes.kt$(HttpStatusCode.OK, SendInvoiceResponse( success = true, transmissionId = result.transmissionId.toString(), status = result.status.name, externalDocumentId = result.externalDocumentId, errorMessage = result.errorMessage ))</ID>
    <ID>Wrapping:SmtpEmailService.kt$SmtpEmailService$(</ID>
    <ID>Wrapping:SmtpEmailService.kt$SmtpEmailService$(props, object : Authenticator() { override fun getPasswordAuthentication(): PasswordAuthentication { return PasswordAuthentication(config.smtp.username, config.smtp.password) } })</ID>
  </CurrentIssues>
</SmellBaseline>
